{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { PLATFORM_ID, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, BehaviorSubject, of, combineLatest, pipe, Observable, fromEventPattern, merge } from 'rxjs';\nimport { take, startWith, combineLatest as combineLatest$1, skipWhile, map, scan, distinctUntilChanged, tap, mergeMap, takeUntil, publish, switchMap, withLatestFrom, filter } from 'rxjs/operators'; /// <reference types=\"youtube\" />\n\nconst _c0 = [\"youtubeContainer\"];\nconst DEFAULT_PLAYER_WIDTH = 640;\nconst DEFAULT_PLAYER_HEIGHT = 390;\n/**\n * Angular component that renders a YouTube player via the YouTube player\n * iframe API.\n * @see https://developers.google.com/youtube/iframe_api_reference\n */\n\nclass YouTubePlayer {\n  constructor(_ngZone, platformId) {\n    this._ngZone = _ngZone;\n    this._youtubeContainer = new Subject();\n    this._destroyed = new Subject();\n    this._playerChanges = new BehaviorSubject(undefined);\n    this._videoId = new BehaviorSubject(undefined);\n    this._height = new BehaviorSubject(DEFAULT_PLAYER_HEIGHT);\n    this._width = new BehaviorSubject(DEFAULT_PLAYER_WIDTH);\n    this._startSeconds = new BehaviorSubject(undefined);\n    this._endSeconds = new BehaviorSubject(undefined);\n    this._suggestedQuality = new BehaviorSubject(undefined);\n    this._playerVars = new BehaviorSubject(undefined);\n    /** Outputs are direct proxies from the player itself. */\n\n    this.ready = this._getLazyEmitter('onReady');\n    this.stateChange = this._getLazyEmitter('onStateChange');\n    this.error = this._getLazyEmitter('onError');\n    this.apiChange = this._getLazyEmitter('onApiChange');\n    this.playbackQualityChange = this._getLazyEmitter('onPlaybackQualityChange');\n    this.playbackRateChange = this._getLazyEmitter('onPlaybackRateChange');\n    this._isBrowser = isPlatformBrowser(platformId);\n  }\n  /** YouTube Video ID to view */\n\n\n  get videoId() {\n    return this._videoId.value;\n  }\n\n  set videoId(videoId) {\n    this._videoId.next(videoId);\n  }\n  /** Height of video player */\n\n\n  get height() {\n    return this._height.value;\n  }\n\n  set height(height) {\n    this._height.next(height || DEFAULT_PLAYER_HEIGHT);\n  }\n  /** Width of video player */\n\n\n  get width() {\n    return this._width.value;\n  }\n\n  set width(width) {\n    this._width.next(width || DEFAULT_PLAYER_WIDTH);\n  }\n  /** The moment when the player is supposed to start playing */\n\n\n  set startSeconds(startSeconds) {\n    this._startSeconds.next(startSeconds);\n  }\n  /** The moment when the player is supposed to stop playing */\n\n\n  set endSeconds(endSeconds) {\n    this._endSeconds.next(endSeconds);\n  }\n  /** The suggested quality of the player */\n\n\n  set suggestedQuality(suggestedQuality) {\n    this._suggestedQuality.next(suggestedQuality);\n  }\n  /**\n   * Extra parameters used to configure the player. See:\n   * https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters\n   */\n\n\n  get playerVars() {\n    return this._playerVars.value;\n  }\n\n  set playerVars(playerVars) {\n    this._playerVars.next(playerVars);\n  }\n\n  ngOnInit() {\n    // Don't do anything if we're not in a browser environment.\n    if (!this._isBrowser) {\n      return;\n    }\n\n    let iframeApiAvailableObs = of(true);\n\n    if (!window.YT || !window.YT.Player) {\n      if (this.showBeforeIframeApiLoads && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw new Error('Namespace YT not found, cannot construct embedded youtube player. ' + 'Please install the YouTube Player API Reference for iframe Embeds: ' + 'https://developers.google.com/youtube/iframe_api_reference');\n      }\n\n      const iframeApiAvailableSubject = new Subject();\n      this._existingApiReadyCallback = window.onYouTubeIframeAPIReady;\n\n      window.onYouTubeIframeAPIReady = () => {\n        if (this._existingApiReadyCallback) {\n          this._existingApiReadyCallback();\n        }\n\n        this._ngZone.run(() => iframeApiAvailableSubject.next(true));\n      };\n\n      iframeApiAvailableObs = iframeApiAvailableSubject.pipe(take(1), startWith(false));\n    } // An observable of the currently loaded player.\n\n\n    const playerObs = createPlayerObservable(this._youtubeContainer, this._videoId, iframeApiAvailableObs, this._width, this._height, this._playerVars, this._ngZone).pipe(tap(player => {\n      // Emit this before the `waitUntilReady` call so that we can bind to\n      // events that happen as the player is being initialized (e.g. `onReady`).\n      this._playerChanges.next(player);\n    }), waitUntilReady(player => {\n      // Destroy the player if loading was aborted so that we don't end up leaking memory.\n      if (!playerIsReady(player)) {\n        player.destroy();\n      }\n    }), takeUntil(this._destroyed), publish()); // Set up side effects to bind inputs to the player.\n\n    playerObs.subscribe(player => {\n      this._player = player;\n\n      if (player && this._pendingPlayerState) {\n        this._initializePlayer(player, this._pendingPlayerState);\n      }\n\n      this._pendingPlayerState = undefined;\n    });\n    bindSizeToPlayer(playerObs, this._width, this._height);\n    bindSuggestedQualityToPlayer(playerObs, this._suggestedQuality);\n    bindCueVideoCall(playerObs, this._videoId, this._startSeconds, this._endSeconds, this._suggestedQuality, this._destroyed); // After all of the subscriptions are set up, connect the observable.\n\n    playerObs.connect();\n  }\n\n  ngAfterViewInit() {\n    this._youtubeContainer.next(this.youtubeContainer.nativeElement);\n  }\n\n  ngOnDestroy() {\n    if (this._player) {\n      this._player.destroy();\n\n      window.onYouTubeIframeAPIReady = this._existingApiReadyCallback;\n    }\n\n    this._playerChanges.complete();\n\n    this._videoId.complete();\n\n    this._height.complete();\n\n    this._width.complete();\n\n    this._startSeconds.complete();\n\n    this._endSeconds.complete();\n\n    this._suggestedQuality.complete();\n\n    this._youtubeContainer.complete();\n\n    this._playerVars.complete();\n\n    this._destroyed.next();\n\n    this._destroyed.complete();\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#playVideo */\n\n\n  playVideo() {\n    if (this._player) {\n      this._player.playVideo();\n    } else {\n      this._getPendingState().playbackState = YT.PlayerState.PLAYING;\n    }\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#pauseVideo */\n\n\n  pauseVideo() {\n    if (this._player) {\n      this._player.pauseVideo();\n    } else {\n      this._getPendingState().playbackState = YT.PlayerState.PAUSED;\n    }\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#stopVideo */\n\n\n  stopVideo() {\n    if (this._player) {\n      this._player.stopVideo();\n    } else {\n      // It seems like YouTube sets the player to CUED when it's stopped.\n      this._getPendingState().playbackState = YT.PlayerState.CUED;\n    }\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#seekTo */\n\n\n  seekTo(seconds, allowSeekAhead) {\n    if (this._player) {\n      this._player.seekTo(seconds, allowSeekAhead);\n    } else {\n      this._getPendingState().seek = {\n        seconds,\n        allowSeekAhead\n      };\n    }\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#mute */\n\n\n  mute() {\n    if (this._player) {\n      this._player.mute();\n    } else {\n      this._getPendingState().muted = true;\n    }\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#unMute */\n\n\n  unMute() {\n    if (this._player) {\n      this._player.unMute();\n    } else {\n      this._getPendingState().muted = false;\n    }\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#isMuted */\n\n\n  isMuted() {\n    if (this._player) {\n      return this._player.isMuted();\n    }\n\n    if (this._pendingPlayerState) {\n      return !!this._pendingPlayerState.muted;\n    }\n\n    return false;\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#setVolume */\n\n\n  setVolume(volume) {\n    if (this._player) {\n      this._player.setVolume(volume);\n    } else {\n      this._getPendingState().volume = volume;\n    }\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getVolume */\n\n\n  getVolume() {\n    if (this._player) {\n      return this._player.getVolume();\n    }\n\n    if (this._pendingPlayerState && this._pendingPlayerState.volume != null) {\n      return this._pendingPlayerState.volume;\n    }\n\n    return 0;\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate */\n\n\n  setPlaybackRate(playbackRate) {\n    if (this._player) {\n      return this._player.setPlaybackRate(playbackRate);\n    } else {\n      this._getPendingState().playbackRate = playbackRate;\n    }\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackRate */\n\n\n  getPlaybackRate() {\n    if (this._player) {\n      return this._player.getPlaybackRate();\n    }\n\n    if (this._pendingPlayerState && this._pendingPlayerState.playbackRate != null) {\n      return this._pendingPlayerState.playbackRate;\n    }\n\n    return 0;\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getAvailablePlaybackRates */\n\n\n  getAvailablePlaybackRates() {\n    return this._player ? this._player.getAvailablePlaybackRates() : [];\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getVideoLoadedFraction */\n\n\n  getVideoLoadedFraction() {\n    return this._player ? this._player.getVideoLoadedFraction() : 0;\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getPlayerState */\n\n\n  getPlayerState() {\n    if (!this._isBrowser || !window.YT) {\n      return undefined;\n    }\n\n    if (this._player) {\n      return this._player.getPlayerState();\n    }\n\n    if (this._pendingPlayerState && this._pendingPlayerState.playbackState != null) {\n      return this._pendingPlayerState.playbackState;\n    }\n\n    return YT.PlayerState.UNSTARTED;\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getCurrentTime */\n\n\n  getCurrentTime() {\n    if (this._player) {\n      return this._player.getCurrentTime();\n    }\n\n    if (this._pendingPlayerState && this._pendingPlayerState.seek) {\n      return this._pendingPlayerState.seek.seconds;\n    }\n\n    return 0;\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackQuality */\n\n\n  getPlaybackQuality() {\n    return this._player ? this._player.getPlaybackQuality() : 'default';\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getAvailableQualityLevels */\n\n\n  getAvailableQualityLevels() {\n    return this._player ? this._player.getAvailableQualityLevels() : [];\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getDuration */\n\n\n  getDuration() {\n    return this._player ? this._player.getDuration() : 0;\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getVideoUrl */\n\n\n  getVideoUrl() {\n    return this._player ? this._player.getVideoUrl() : '';\n  }\n  /** See https://developers.google.com/youtube/iframe_api_reference#getVideoEmbedCode */\n\n\n  getVideoEmbedCode() {\n    return this._player ? this._player.getVideoEmbedCode() : '';\n  }\n  /** Gets an object that should be used to store the temporary API state. */\n\n\n  _getPendingState() {\n    if (!this._pendingPlayerState) {\n      this._pendingPlayerState = {};\n    }\n\n    return this._pendingPlayerState;\n  }\n  /** Initializes a player from a temporary state. */\n\n\n  _initializePlayer(player, state) {\n    const {\n      playbackState,\n      playbackRate,\n      volume,\n      muted,\n      seek\n    } = state;\n\n    switch (playbackState) {\n      case YT.PlayerState.PLAYING:\n        player.playVideo();\n        break;\n\n      case YT.PlayerState.PAUSED:\n        player.pauseVideo();\n        break;\n\n      case YT.PlayerState.CUED:\n        player.stopVideo();\n        break;\n    }\n\n    if (playbackRate != null) {\n      player.setPlaybackRate(playbackRate);\n    }\n\n    if (volume != null) {\n      player.setVolume(volume);\n    }\n\n    if (muted != null) {\n      muted ? player.mute() : player.unMute();\n    }\n\n    if (seek != null) {\n      player.seekTo(seek.seconds, seek.allowSeekAhead);\n    }\n  }\n  /** Gets an observable that adds an event listener to the player when a user subscribes to it. */\n\n\n  _getLazyEmitter(name) {\n    // Start with the stream of players. This way the events will be transferred\n    // over to the new player if it gets swapped out under-the-hood.\n    return this._playerChanges.pipe( // Switch to the bound event. `switchMap` ensures that the old event is removed when the\n    // player is changed. If there's no player, return an observable that never emits.\n    switchMap(player => {\n      return player ? fromEventPattern(listener => {\n        player.addEventListener(name, listener);\n      }, listener => {\n        // The API seems to throw when we try to unbind from a destroyed player and it doesn't\n        // expose whether the player has been destroyed so we have to wrap it in a try/catch to\n        // prevent the entire stream from erroring out.\n        try {\n          if (player.removeEventListener) {\n            player.removeEventListener(name, listener);\n          }\n        } catch {}\n      }) : of();\n    }), // By default we run all the API interactions outside the zone\n    // so we have to bring the events back in manually when they emit.\n    source => new Observable(observer => source.subscribe({\n      next: value => this._ngZone.run(() => observer.next(value)),\n      error: error => observer.error(error),\n      complete: () => observer.complete()\n    })), // Ensures that everything is cleared out on destroy.\n    takeUntil(this._destroyed));\n  }\n\n}\n\nYouTubePlayer.ɵfac = function YouTubePlayer_Factory(t) {\n  return new (t || YouTubePlayer)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID));\n};\n\nYouTubePlayer.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: YouTubePlayer,\n  selectors: [[\"youtube-player\"]],\n  viewQuery: function YouTubePlayer_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.youtubeContainer = _t.first);\n    }\n  },\n  inputs: {\n    videoId: \"videoId\",\n    height: \"height\",\n    width: \"width\",\n    startSeconds: \"startSeconds\",\n    endSeconds: \"endSeconds\",\n    suggestedQuality: \"suggestedQuality\",\n    playerVars: \"playerVars\",\n    showBeforeIframeApiLoads: \"showBeforeIframeApiLoads\"\n  },\n  outputs: {\n    ready: \"ready\",\n    stateChange: \"stateChange\",\n    error: \"error\",\n    apiChange: \"apiChange\",\n    playbackQualityChange: \"playbackQualityChange\",\n    playbackRateChange: \"playbackRateChange\"\n  },\n  decls: 2,\n  vars: 0,\n  consts: [[\"youtubeContainer\", \"\"]],\n  template: function YouTubePlayer_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelement(0, \"div\", null, 0);\n    }\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(YouTubePlayer, [{\n    type: Component,\n    args: [{\n      selector: 'youtube-player',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      encapsulation: ViewEncapsulation.None,\n      // This div is *replaced* by the YouTube player embed.\n      template: '<div #youtubeContainer></div>'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }, {\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, {\n    videoId: [{\n      type: Input\n    }],\n    height: [{\n      type: Input\n    }],\n    width: [{\n      type: Input\n    }],\n    startSeconds: [{\n      type: Input\n    }],\n    endSeconds: [{\n      type: Input\n    }],\n    suggestedQuality: [{\n      type: Input\n    }],\n    playerVars: [{\n      type: Input\n    }],\n    showBeforeIframeApiLoads: [{\n      type: Input\n    }],\n    ready: [{\n      type: Output\n    }],\n    stateChange: [{\n      type: Output\n    }],\n    error: [{\n      type: Output\n    }],\n    apiChange: [{\n      type: Output\n    }],\n    playbackQualityChange: [{\n      type: Output\n    }],\n    playbackRateChange: [{\n      type: Output\n    }],\n    youtubeContainer: [{\n      type: ViewChild,\n      args: ['youtubeContainer']\n    }]\n  });\n})();\n/** Listens to changes to the given width and height and sets it on the player. */\n\n\nfunction bindSizeToPlayer(playerObs, widthObs, heightObs) {\n  return combineLatest([playerObs, widthObs, heightObs]).subscribe(([player, width, height]) => player && player.setSize(width, height));\n}\n/** Listens to changes from the suggested quality and sets it on the given player. */\n\n\nfunction bindSuggestedQualityToPlayer(playerObs, suggestedQualityObs) {\n  return combineLatest([playerObs, suggestedQualityObs]).subscribe(([player, suggestedQuality]) => player && suggestedQuality && player.setPlaybackQuality(suggestedQuality));\n}\n/**\n * Returns an observable that emits the loaded player once it's ready. Certain properties/methods\n * won't be available until the iframe finishes loading.\n * @param onAbort Callback function that will be invoked if the player loading was aborted before\n * it was able to complete. Can be used to clean up any loose references.\n */\n\n\nfunction waitUntilReady(onAbort) {\n  return mergeMap(player => {\n    if (!player) {\n      return of(undefined);\n    }\n\n    if (playerIsReady(player)) {\n      return of(player);\n    } // Since removeEventListener is not on Player when it's initialized, we can't use fromEvent.\n    // The player is not initialized fully until the ready is called.\n\n\n    return new Observable(emitter => {\n      let aborted = false;\n      let resolved = false;\n\n      const onReady = event => {\n        resolved = true;\n\n        if (!aborted) {\n          event.target.removeEventListener('onReady', onReady);\n          emitter.next(event.target);\n        }\n      };\n\n      player.addEventListener('onReady', onReady);\n      return () => {\n        aborted = true;\n\n        if (!resolved) {\n          onAbort(player);\n        }\n      };\n    }).pipe(take(1), startWith(undefined));\n  });\n}\n/** Create an observable for the player based on the given options. */\n\n\nfunction createPlayerObservable(youtubeContainer, videoIdObs, iframeApiAvailableObs, widthObs, heightObs, playerVarsObs, ngZone) {\n  const playerOptions = combineLatest([videoIdObs, playerVarsObs]).pipe(withLatestFrom(combineLatest([widthObs, heightObs])), map(([constructorOptions, sizeOptions]) => {\n    const [videoId, playerVars] = constructorOptions;\n    const [width, height] = sizeOptions;\n    return videoId ? {\n      videoId,\n      playerVars,\n      width,\n      height\n    } : undefined;\n  }));\n  return combineLatest([youtubeContainer, playerOptions, of(ngZone)]).pipe(skipUntilRememberLatest(iframeApiAvailableObs), scan(syncPlayerState, undefined), distinctUntilChanged());\n}\n/** Skips the given observable until the other observable emits true, then emit the latest. */\n\n\nfunction skipUntilRememberLatest(notifier) {\n  return pipe(combineLatest$1(notifier), skipWhile(([_, doneSkipping]) => !doneSkipping), map(([value]) => value));\n}\n/** Destroy the player if there are no options, or create the player if there are options. */\n\n\nfunction syncPlayerState(player, [container, videoOptions, ngZone]) {\n  if (player && videoOptions && player.playerVars !== videoOptions.playerVars) {\n    // The player needs to be recreated if the playerVars are different.\n    player.destroy();\n  } else if (!videoOptions) {\n    if (player) {\n      // Destroy the player if the videoId was removed.\n      player.destroy();\n    }\n\n    return;\n  } else if (player) {\n    return player;\n  } // Important! We need to create the Player object outside of the `NgZone`, because it kicks\n  // off a 250ms setInterval which will continually trigger change detection if we don't.\n\n\n  const newPlayer = ngZone.runOutsideAngular(() => new YT.Player(container, videoOptions));\n  newPlayer.videoId = videoOptions.videoId;\n  newPlayer.playerVars = videoOptions.playerVars;\n  return newPlayer;\n}\n/**\n * Call cueVideoById if the videoId changes, or when start or end seconds change. cueVideoById will\n * change the loaded video id to the given videoId, and set the start and end times to the given\n * start/end seconds.\n */\n\n\nfunction bindCueVideoCall(playerObs, videoIdObs, startSecondsObs, endSecondsObs, suggestedQualityObs, destroyed) {\n  const cueOptionsObs = combineLatest([startSecondsObs, endSecondsObs]).pipe(map(([startSeconds, endSeconds]) => ({\n    startSeconds,\n    endSeconds\n  }))); // Only respond to changes in cue options if the player is not running.\n\n  const filteredCueOptions = cueOptionsObs.pipe(filterOnOther(playerObs, player => !!player && !hasPlayerStarted(player))); // If the video id changed, there's no reason to run 'cue' unless the player\n  // was initialized with a different video id.\n\n  const changedVideoId = videoIdObs.pipe(filterOnOther(playerObs, (player, videoId) => !!player && player.videoId !== videoId)); // If the player changed, there's no reason to run 'cue' unless there are cue options.\n\n  const changedPlayer = playerObs.pipe(filterOnOther(combineLatest([videoIdObs, cueOptionsObs]), ([videoId, cueOptions], player) => !!player && (videoId != player.videoId || !!cueOptions.startSeconds || !!cueOptions.endSeconds)));\n  merge(changedPlayer, changedVideoId, filteredCueOptions).pipe(withLatestFrom(combineLatest([playerObs, videoIdObs, cueOptionsObs, suggestedQualityObs])), map(([_, values]) => values), takeUntil(destroyed)).subscribe(([player, videoId, cueOptions, suggestedQuality]) => {\n    if (!videoId || !player) {\n      return;\n    }\n\n    player.videoId = videoId;\n    player.cueVideoById({\n      videoId,\n      suggestedQuality,\n      ...cueOptions\n    });\n  });\n}\n\nfunction hasPlayerStarted(player) {\n  const state = player.getPlayerState();\n  return state !== YT.PlayerState.UNSTARTED && state !== YT.PlayerState.CUED;\n}\n\nfunction playerIsReady(player) {\n  return 'getPlayerStatus' in player;\n}\n/** Combines the two observables temporarily for the filter function. */\n\n\nfunction filterOnOther(otherObs, filterFn) {\n  return pipe(withLatestFrom(otherObs), filter(([value, other]) => filterFn(other, value)), map(([value]) => value));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst COMPONENTS = [YouTubePlayer];\n\nclass YouTubePlayerModule {}\n\nYouTubePlayerModule.ɵfac = function YouTubePlayerModule_Factory(t) {\n  return new (t || YouTubePlayerModule)();\n};\n\nYouTubePlayerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: YouTubePlayerModule\n});\nYouTubePlayerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(YouTubePlayerModule, [{\n    type: NgModule,\n    args: [{\n      declarations: COMPONENTS,\n      exports: COMPONENTS\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { YouTubePlayer, YouTubePlayerModule };","map":{"version":3,"names":["i0","PLATFORM_ID","Component","ChangeDetectionStrategy","ViewEncapsulation","Inject","Input","Output","ViewChild","NgModule","isPlatformBrowser","Subject","BehaviorSubject","of","combineLatest","pipe","Observable","fromEventPattern","merge","take","startWith","combineLatest$1","skipWhile","map","scan","distinctUntilChanged","tap","mergeMap","takeUntil","publish","switchMap","withLatestFrom","filter","DEFAULT_PLAYER_WIDTH","DEFAULT_PLAYER_HEIGHT","YouTubePlayer","constructor","_ngZone","platformId","_youtubeContainer","_destroyed","_playerChanges","undefined","_videoId","_height","_width","_startSeconds","_endSeconds","_suggestedQuality","_playerVars","ready","_getLazyEmitter","stateChange","error","apiChange","playbackQualityChange","playbackRateChange","_isBrowser","videoId","value","next","height","width","startSeconds","endSeconds","suggestedQuality","playerVars","ngOnInit","iframeApiAvailableObs","window","YT","Player","showBeforeIframeApiLoads","ngDevMode","Error","iframeApiAvailableSubject","_existingApiReadyCallback","onYouTubeIframeAPIReady","run","playerObs","createPlayerObservable","player","waitUntilReady","playerIsReady","destroy","subscribe","_player","_pendingPlayerState","_initializePlayer","bindSizeToPlayer","bindSuggestedQualityToPlayer","bindCueVideoCall","connect","ngAfterViewInit","youtubeContainer","nativeElement","ngOnDestroy","complete","playVideo","_getPendingState","playbackState","PlayerState","PLAYING","pauseVideo","PAUSED","stopVideo","CUED","seekTo","seconds","allowSeekAhead","seek","mute","muted","unMute","isMuted","setVolume","volume","getVolume","setPlaybackRate","playbackRate","getPlaybackRate","getAvailablePlaybackRates","getVideoLoadedFraction","getPlayerState","UNSTARTED","getCurrentTime","getPlaybackQuality","getAvailableQualityLevels","getDuration","getVideoUrl","getVideoEmbedCode","state","name","listener","addEventListener","removeEventListener","source","observer","ɵfac","NgZone","ɵcmp","type","args","selector","changeDetection","OnPush","encapsulation","None","template","Object","decorators","widthObs","heightObs","setSize","suggestedQualityObs","setPlaybackQuality","onAbort","emitter","aborted","resolved","onReady","event","target","videoIdObs","playerVarsObs","ngZone","playerOptions","constructorOptions","sizeOptions","skipUntilRememberLatest","syncPlayerState","notifier","_","doneSkipping","container","videoOptions","newPlayer","runOutsideAngular","startSecondsObs","endSecondsObs","destroyed","cueOptionsObs","filteredCueOptions","filterOnOther","hasPlayerStarted","changedVideoId","changedPlayer","cueOptions","values","cueVideoById","otherObs","filterFn","other","COMPONENTS","YouTubePlayerModule","ɵmod","ɵinj","declarations","exports"],"sources":["/Users/cisip/Desktop/spaceepod/node_modules/@angular/youtube-player/fesm2020/youtube-player.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { PLATFORM_ID, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, BehaviorSubject, of, combineLatest, pipe, Observable, fromEventPattern, merge } from 'rxjs';\nimport { take, startWith, combineLatest as combineLatest$1, skipWhile, map, scan, distinctUntilChanged, tap, mergeMap, takeUntil, publish, switchMap, withLatestFrom, filter } from 'rxjs/operators';\n\n/// <reference types=\"youtube\" />\nconst DEFAULT_PLAYER_WIDTH = 640;\nconst DEFAULT_PLAYER_HEIGHT = 390;\n/**\n * Angular component that renders a YouTube player via the YouTube player\n * iframe API.\n * @see https://developers.google.com/youtube/iframe_api_reference\n */\nclass YouTubePlayer {\n    constructor(_ngZone, platformId) {\n        this._ngZone = _ngZone;\n        this._youtubeContainer = new Subject();\n        this._destroyed = new Subject();\n        this._playerChanges = new BehaviorSubject(undefined);\n        this._videoId = new BehaviorSubject(undefined);\n        this._height = new BehaviorSubject(DEFAULT_PLAYER_HEIGHT);\n        this._width = new BehaviorSubject(DEFAULT_PLAYER_WIDTH);\n        this._startSeconds = new BehaviorSubject(undefined);\n        this._endSeconds = new BehaviorSubject(undefined);\n        this._suggestedQuality = new BehaviorSubject(undefined);\n        this._playerVars = new BehaviorSubject(undefined);\n        /** Outputs are direct proxies from the player itself. */\n        this.ready = this._getLazyEmitter('onReady');\n        this.stateChange = this._getLazyEmitter('onStateChange');\n        this.error = this._getLazyEmitter('onError');\n        this.apiChange = this._getLazyEmitter('onApiChange');\n        this.playbackQualityChange = this._getLazyEmitter('onPlaybackQualityChange');\n        this.playbackRateChange = this._getLazyEmitter('onPlaybackRateChange');\n        this._isBrowser = isPlatformBrowser(platformId);\n    }\n    /** YouTube Video ID to view */\n    get videoId() {\n        return this._videoId.value;\n    }\n    set videoId(videoId) {\n        this._videoId.next(videoId);\n    }\n    /** Height of video player */\n    get height() {\n        return this._height.value;\n    }\n    set height(height) {\n        this._height.next(height || DEFAULT_PLAYER_HEIGHT);\n    }\n    /** Width of video player */\n    get width() {\n        return this._width.value;\n    }\n    set width(width) {\n        this._width.next(width || DEFAULT_PLAYER_WIDTH);\n    }\n    /** The moment when the player is supposed to start playing */\n    set startSeconds(startSeconds) {\n        this._startSeconds.next(startSeconds);\n    }\n    /** The moment when the player is supposed to stop playing */\n    set endSeconds(endSeconds) {\n        this._endSeconds.next(endSeconds);\n    }\n    /** The suggested quality of the player */\n    set suggestedQuality(suggestedQuality) {\n        this._suggestedQuality.next(suggestedQuality);\n    }\n    /**\n     * Extra parameters used to configure the player. See:\n     * https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters\n     */\n    get playerVars() {\n        return this._playerVars.value;\n    }\n    set playerVars(playerVars) {\n        this._playerVars.next(playerVars);\n    }\n    ngOnInit() {\n        // Don't do anything if we're not in a browser environment.\n        if (!this._isBrowser) {\n            return;\n        }\n        let iframeApiAvailableObs = of(true);\n        if (!window.YT || !window.YT.Player) {\n            if (this.showBeforeIframeApiLoads && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw new Error('Namespace YT not found, cannot construct embedded youtube player. ' +\n                    'Please install the YouTube Player API Reference for iframe Embeds: ' +\n                    'https://developers.google.com/youtube/iframe_api_reference');\n            }\n            const iframeApiAvailableSubject = new Subject();\n            this._existingApiReadyCallback = window.onYouTubeIframeAPIReady;\n            window.onYouTubeIframeAPIReady = () => {\n                if (this._existingApiReadyCallback) {\n                    this._existingApiReadyCallback();\n                }\n                this._ngZone.run(() => iframeApiAvailableSubject.next(true));\n            };\n            iframeApiAvailableObs = iframeApiAvailableSubject.pipe(take(1), startWith(false));\n        }\n        // An observable of the currently loaded player.\n        const playerObs = createPlayerObservable(this._youtubeContainer, this._videoId, iframeApiAvailableObs, this._width, this._height, this._playerVars, this._ngZone).pipe(tap(player => {\n            // Emit this before the `waitUntilReady` call so that we can bind to\n            // events that happen as the player is being initialized (e.g. `onReady`).\n            this._playerChanges.next(player);\n        }), waitUntilReady(player => {\n            // Destroy the player if loading was aborted so that we don't end up leaking memory.\n            if (!playerIsReady(player)) {\n                player.destroy();\n            }\n        }), takeUntil(this._destroyed), publish());\n        // Set up side effects to bind inputs to the player.\n        playerObs.subscribe(player => {\n            this._player = player;\n            if (player && this._pendingPlayerState) {\n                this._initializePlayer(player, this._pendingPlayerState);\n            }\n            this._pendingPlayerState = undefined;\n        });\n        bindSizeToPlayer(playerObs, this._width, this._height);\n        bindSuggestedQualityToPlayer(playerObs, this._suggestedQuality);\n        bindCueVideoCall(playerObs, this._videoId, this._startSeconds, this._endSeconds, this._suggestedQuality, this._destroyed);\n        // After all of the subscriptions are set up, connect the observable.\n        playerObs.connect();\n    }\n    ngAfterViewInit() {\n        this._youtubeContainer.next(this.youtubeContainer.nativeElement);\n    }\n    ngOnDestroy() {\n        if (this._player) {\n            this._player.destroy();\n            window.onYouTubeIframeAPIReady = this._existingApiReadyCallback;\n        }\n        this._playerChanges.complete();\n        this._videoId.complete();\n        this._height.complete();\n        this._width.complete();\n        this._startSeconds.complete();\n        this._endSeconds.complete();\n        this._suggestedQuality.complete();\n        this._youtubeContainer.complete();\n        this._playerVars.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#playVideo */\n    playVideo() {\n        if (this._player) {\n            this._player.playVideo();\n        }\n        else {\n            this._getPendingState().playbackState = YT.PlayerState.PLAYING;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#pauseVideo */\n    pauseVideo() {\n        if (this._player) {\n            this._player.pauseVideo();\n        }\n        else {\n            this._getPendingState().playbackState = YT.PlayerState.PAUSED;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#stopVideo */\n    stopVideo() {\n        if (this._player) {\n            this._player.stopVideo();\n        }\n        else {\n            // It seems like YouTube sets the player to CUED when it's stopped.\n            this._getPendingState().playbackState = YT.PlayerState.CUED;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#seekTo */\n    seekTo(seconds, allowSeekAhead) {\n        if (this._player) {\n            this._player.seekTo(seconds, allowSeekAhead);\n        }\n        else {\n            this._getPendingState().seek = { seconds, allowSeekAhead };\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#mute */\n    mute() {\n        if (this._player) {\n            this._player.mute();\n        }\n        else {\n            this._getPendingState().muted = true;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#unMute */\n    unMute() {\n        if (this._player) {\n            this._player.unMute();\n        }\n        else {\n            this._getPendingState().muted = false;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#isMuted */\n    isMuted() {\n        if (this._player) {\n            return this._player.isMuted();\n        }\n        if (this._pendingPlayerState) {\n            return !!this._pendingPlayerState.muted;\n        }\n        return false;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setVolume */\n    setVolume(volume) {\n        if (this._player) {\n            this._player.setVolume(volume);\n        }\n        else {\n            this._getPendingState().volume = volume;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVolume */\n    getVolume() {\n        if (this._player) {\n            return this._player.getVolume();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.volume != null) {\n            return this._pendingPlayerState.volume;\n        }\n        return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate */\n    setPlaybackRate(playbackRate) {\n        if (this._player) {\n            return this._player.setPlaybackRate(playbackRate);\n        }\n        else {\n            this._getPendingState().playbackRate = playbackRate;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackRate */\n    getPlaybackRate() {\n        if (this._player) {\n            return this._player.getPlaybackRate();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.playbackRate != null) {\n            return this._pendingPlayerState.playbackRate;\n        }\n        return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailablePlaybackRates */\n    getAvailablePlaybackRates() {\n        return this._player ? this._player.getAvailablePlaybackRates() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoLoadedFraction */\n    getVideoLoadedFraction() {\n        return this._player ? this._player.getVideoLoadedFraction() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlayerState */\n    getPlayerState() {\n        if (!this._isBrowser || !window.YT) {\n            return undefined;\n        }\n        if (this._player) {\n            return this._player.getPlayerState();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.playbackState != null) {\n            return this._pendingPlayerState.playbackState;\n        }\n        return YT.PlayerState.UNSTARTED;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getCurrentTime */\n    getCurrentTime() {\n        if (this._player) {\n            return this._player.getCurrentTime();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.seek) {\n            return this._pendingPlayerState.seek.seconds;\n        }\n        return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackQuality */\n    getPlaybackQuality() {\n        return this._player ? this._player.getPlaybackQuality() : 'default';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailableQualityLevels */\n    getAvailableQualityLevels() {\n        return this._player ? this._player.getAvailableQualityLevels() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getDuration */\n    getDuration() {\n        return this._player ? this._player.getDuration() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoUrl */\n    getVideoUrl() {\n        return this._player ? this._player.getVideoUrl() : '';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoEmbedCode */\n    getVideoEmbedCode() {\n        return this._player ? this._player.getVideoEmbedCode() : '';\n    }\n    /** Gets an object that should be used to store the temporary API state. */\n    _getPendingState() {\n        if (!this._pendingPlayerState) {\n            this._pendingPlayerState = {};\n        }\n        return this._pendingPlayerState;\n    }\n    /** Initializes a player from a temporary state. */\n    _initializePlayer(player, state) {\n        const { playbackState, playbackRate, volume, muted, seek } = state;\n        switch (playbackState) {\n            case YT.PlayerState.PLAYING:\n                player.playVideo();\n                break;\n            case YT.PlayerState.PAUSED:\n                player.pauseVideo();\n                break;\n            case YT.PlayerState.CUED:\n                player.stopVideo();\n                break;\n        }\n        if (playbackRate != null) {\n            player.setPlaybackRate(playbackRate);\n        }\n        if (volume != null) {\n            player.setVolume(volume);\n        }\n        if (muted != null) {\n            muted ? player.mute() : player.unMute();\n        }\n        if (seek != null) {\n            player.seekTo(seek.seconds, seek.allowSeekAhead);\n        }\n    }\n    /** Gets an observable that adds an event listener to the player when a user subscribes to it. */\n    _getLazyEmitter(name) {\n        // Start with the stream of players. This way the events will be transferred\n        // over to the new player if it gets swapped out under-the-hood.\n        return this._playerChanges.pipe(\n        // Switch to the bound event. `switchMap` ensures that the old event is removed when the\n        // player is changed. If there's no player, return an observable that never emits.\n        switchMap(player => {\n            return player\n                ? fromEventPattern((listener) => {\n                    player.addEventListener(name, listener);\n                }, (listener) => {\n                    // The API seems to throw when we try to unbind from a destroyed player and it doesn't\n                    // expose whether the player has been destroyed so we have to wrap it in a try/catch to\n                    // prevent the entire stream from erroring out.\n                    try {\n                        if (player.removeEventListener) {\n                            player.removeEventListener(name, listener);\n                        }\n                    }\n                    catch { }\n                })\n                : of();\n        }), \n        // By default we run all the API interactions outside the zone\n        // so we have to bring the events back in manually when they emit.\n        (source) => new Observable(observer => source.subscribe({\n            next: value => this._ngZone.run(() => observer.next(value)),\n            error: error => observer.error(error),\n            complete: () => observer.complete(),\n        })), \n        // Ensures that everything is cleared out on destroy.\n        takeUntil(this._destroyed));\n    }\n}\nYouTubePlayer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.0.1\", ngImport: i0, type: YouTubePlayer, deps: [{ token: i0.NgZone }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });\nYouTubePlayer.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"14.0.1\", type: YouTubePlayer, selector: \"youtube-player\", inputs: { videoId: \"videoId\", height: \"height\", width: \"width\", startSeconds: \"startSeconds\", endSeconds: \"endSeconds\", suggestedQuality: \"suggestedQuality\", playerVars: \"playerVars\", showBeforeIframeApiLoads: \"showBeforeIframeApiLoads\" }, outputs: { ready: \"ready\", stateChange: \"stateChange\", error: \"error\", apiChange: \"apiChange\", playbackQualityChange: \"playbackQualityChange\", playbackRateChange: \"playbackRateChange\" }, viewQueries: [{ propertyName: \"youtubeContainer\", first: true, predicate: [\"youtubeContainer\"], descendants: true }], ngImport: i0, template: '<div #youtubeContainer></div>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.0.1\", ngImport: i0, type: YouTubePlayer, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'youtube-player',\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    encapsulation: ViewEncapsulation.None,\n                    // This div is *replaced* by the YouTube player embed.\n                    template: '<div #youtubeContainer></div>',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: Object, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; }, propDecorators: { videoId: [{\n                type: Input\n            }], height: [{\n                type: Input\n            }], width: [{\n                type: Input\n            }], startSeconds: [{\n                type: Input\n            }], endSeconds: [{\n                type: Input\n            }], suggestedQuality: [{\n                type: Input\n            }], playerVars: [{\n                type: Input\n            }], showBeforeIframeApiLoads: [{\n                type: Input\n            }], ready: [{\n                type: Output\n            }], stateChange: [{\n                type: Output\n            }], error: [{\n                type: Output\n            }], apiChange: [{\n                type: Output\n            }], playbackQualityChange: [{\n                type: Output\n            }], playbackRateChange: [{\n                type: Output\n            }], youtubeContainer: [{\n                type: ViewChild,\n                args: ['youtubeContainer']\n            }] } });\n/** Listens to changes to the given width and height and sets it on the player. */\nfunction bindSizeToPlayer(playerObs, widthObs, heightObs) {\n    return combineLatest([playerObs, widthObs, heightObs]).subscribe(([player, width, height]) => player && player.setSize(width, height));\n}\n/** Listens to changes from the suggested quality and sets it on the given player. */\nfunction bindSuggestedQualityToPlayer(playerObs, suggestedQualityObs) {\n    return combineLatest([playerObs, suggestedQualityObs]).subscribe(([player, suggestedQuality]) => player && suggestedQuality && player.setPlaybackQuality(suggestedQuality));\n}\n/**\n * Returns an observable that emits the loaded player once it's ready. Certain properties/methods\n * won't be available until the iframe finishes loading.\n * @param onAbort Callback function that will be invoked if the player loading was aborted before\n * it was able to complete. Can be used to clean up any loose references.\n */\nfunction waitUntilReady(onAbort) {\n    return mergeMap(player => {\n        if (!player) {\n            return of(undefined);\n        }\n        if (playerIsReady(player)) {\n            return of(player);\n        }\n        // Since removeEventListener is not on Player when it's initialized, we can't use fromEvent.\n        // The player is not initialized fully until the ready is called.\n        return new Observable(emitter => {\n            let aborted = false;\n            let resolved = false;\n            const onReady = (event) => {\n                resolved = true;\n                if (!aborted) {\n                    event.target.removeEventListener('onReady', onReady);\n                    emitter.next(event.target);\n                }\n            };\n            player.addEventListener('onReady', onReady);\n            return () => {\n                aborted = true;\n                if (!resolved) {\n                    onAbort(player);\n                }\n            };\n        }).pipe(take(1), startWith(undefined));\n    });\n}\n/** Create an observable for the player based on the given options. */\nfunction createPlayerObservable(youtubeContainer, videoIdObs, iframeApiAvailableObs, widthObs, heightObs, playerVarsObs, ngZone) {\n    const playerOptions = combineLatest([videoIdObs, playerVarsObs]).pipe(withLatestFrom(combineLatest([widthObs, heightObs])), map(([constructorOptions, sizeOptions]) => {\n        const [videoId, playerVars] = constructorOptions;\n        const [width, height] = sizeOptions;\n        return videoId ? { videoId, playerVars, width, height } : undefined;\n    }));\n    return combineLatest([youtubeContainer, playerOptions, of(ngZone)]).pipe(skipUntilRememberLatest(iframeApiAvailableObs), scan(syncPlayerState, undefined), distinctUntilChanged());\n}\n/** Skips the given observable until the other observable emits true, then emit the latest. */\nfunction skipUntilRememberLatest(notifier) {\n    return pipe(combineLatest$1(notifier), skipWhile(([_, doneSkipping]) => !doneSkipping), map(([value]) => value));\n}\n/** Destroy the player if there are no options, or create the player if there are options. */\nfunction syncPlayerState(player, [container, videoOptions, ngZone]) {\n    if (player && videoOptions && player.playerVars !== videoOptions.playerVars) {\n        // The player needs to be recreated if the playerVars are different.\n        player.destroy();\n    }\n    else if (!videoOptions) {\n        if (player) {\n            // Destroy the player if the videoId was removed.\n            player.destroy();\n        }\n        return;\n    }\n    else if (player) {\n        return player;\n    }\n    // Important! We need to create the Player object outside of the `NgZone`, because it kicks\n    // off a 250ms setInterval which will continually trigger change detection if we don't.\n    const newPlayer = ngZone.runOutsideAngular(() => new YT.Player(container, videoOptions));\n    newPlayer.videoId = videoOptions.videoId;\n    newPlayer.playerVars = videoOptions.playerVars;\n    return newPlayer;\n}\n/**\n * Call cueVideoById if the videoId changes, or when start or end seconds change. cueVideoById will\n * change the loaded video id to the given videoId, and set the start and end times to the given\n * start/end seconds.\n */\nfunction bindCueVideoCall(playerObs, videoIdObs, startSecondsObs, endSecondsObs, suggestedQualityObs, destroyed) {\n    const cueOptionsObs = combineLatest([startSecondsObs, endSecondsObs]).pipe(map(([startSeconds, endSeconds]) => ({ startSeconds, endSeconds })));\n    // Only respond to changes in cue options if the player is not running.\n    const filteredCueOptions = cueOptionsObs.pipe(filterOnOther(playerObs, player => !!player && !hasPlayerStarted(player)));\n    // If the video id changed, there's no reason to run 'cue' unless the player\n    // was initialized with a different video id.\n    const changedVideoId = videoIdObs.pipe(filterOnOther(playerObs, (player, videoId) => !!player && player.videoId !== videoId));\n    // If the player changed, there's no reason to run 'cue' unless there are cue options.\n    const changedPlayer = playerObs.pipe(filterOnOther(combineLatest([videoIdObs, cueOptionsObs]), ([videoId, cueOptions], player) => !!player &&\n        (videoId != player.videoId || !!cueOptions.startSeconds || !!cueOptions.endSeconds)));\n    merge(changedPlayer, changedVideoId, filteredCueOptions)\n        .pipe(withLatestFrom(combineLatest([playerObs, videoIdObs, cueOptionsObs, suggestedQualityObs])), map(([_, values]) => values), takeUntil(destroyed))\n        .subscribe(([player, videoId, cueOptions, suggestedQuality]) => {\n        if (!videoId || !player) {\n            return;\n        }\n        player.videoId = videoId;\n        player.cueVideoById({\n            videoId,\n            suggestedQuality,\n            ...cueOptions,\n        });\n    });\n}\nfunction hasPlayerStarted(player) {\n    const state = player.getPlayerState();\n    return state !== YT.PlayerState.UNSTARTED && state !== YT.PlayerState.CUED;\n}\nfunction playerIsReady(player) {\n    return 'getPlayerStatus' in player;\n}\n/** Combines the two observables temporarily for the filter function. */\nfunction filterOnOther(otherObs, filterFn) {\n    return pipe(withLatestFrom(otherObs), filter(([value, other]) => filterFn(other, value)), map(([value]) => value));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst COMPONENTS = [YouTubePlayer];\nclass YouTubePlayerModule {\n}\nYouTubePlayerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.0.1\", ngImport: i0, type: YouTubePlayerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nYouTubePlayerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.0.1\", ngImport: i0, type: YouTubePlayerModule, declarations: [YouTubePlayer], exports: [YouTubePlayer] });\nYouTubePlayerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.0.1\", ngImport: i0, type: YouTubePlayerModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.0.1\", ngImport: i0, type: YouTubePlayerModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: COMPONENTS,\n                    exports: COMPONENTS,\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { YouTubePlayer, YouTubePlayerModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}